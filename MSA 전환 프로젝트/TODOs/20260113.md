eb-batch // 2026년 1월 14일 @김헌중님 요청사항(w이효신님)
- java 25, spring boot 4.x 기반으로 변경 예정
  - java 25 설치 필요
  - gradle 9.x 설치 필요


HTTP interface
https://www.baeldung.com/spring-6-http-interface#client-proxy
- 리서치 중
- 레지스트리 와 연동 시 사용 방안 고민


---
# 프레임워크 개선작업

# 의존성 정리 - 2025/01/14
* logback-kafka-appender - 제거
* logstash-logback-encoder - 사용 여부 확인 후 제거. 필요 시 직접 추가하도록 가이드

* org.junit.jupiter:junit-jupiter, org.junit.vintage:junit-vintage-engine - 제거

* ch.qos.logback:logback-access -> 내장 logback 으로 대체여부 점검

* poiVersion = "5.5.1" 

* org.apache.logging.log4j:log4j-api
* org.apache.logging.log4j:log4j-to-slf4j
  * log4j 취약점(CVE-2021-44228) 패치 작업. spring-boot-starter에서 제외가 되지 않아 반대로 패치된 버전을 추가하여 방지함. 이제 정리해도 되는저 점검필요

# 패키지 정리 - 2025/01/14
purple-api-support 내 코드 정리
* ResourceClientBasicConfig 를 resourceclient 패키지 하위로 이동 후 정리


# RestApiClient - 2025/01/15, branch: feature/java25, 
* RestClientProperties#maxResponseSize -> 삭제 처리


# 기능과 정책은 분리 - 진행중
* 정책은 선택하여 적용할 수 있도록 구성

# 의존성 정리 2단계
* httpclientVersion = "4.5.14" - 점검 필요


----



# 설계
## 기본 구성
* spring boot 4.x 기반으로 구성(java 25)

RestApiClient -> HTTP Service Interface 기반으로 변경

* HTTP Service Interface 기반으로 구성
  * @ImportHttpService 를 사용하여 restclient 를 구성
  * 사용 최적화 방안 검토 필요

## 핵심 기능
  * router
    * 라우터 - 목적지를 동적으로 관리

  * locator
    * 분배기 - 어디에서 요청을 가져와서 어디로 보낼것 인가

  * Predicate
    * 검증기 - 요청이 유효한지 검증, 유효한 요청일 경우 processor 호출
      * 검증 대상
        * 헤더
        * path -> ant pattern
        * HTTP 메소드
        * 쿠키

  * processor
    * 실행기 - 요청을 처리하고 응답을 반환
    * restclient 를 사용 - HTTP interface clients 사용(@ImportHttpServices)
    * interface 기반으로 구성을 통해, bff 구성 시 부서별로 원하는 기능만 선택하여 구현 가능
      * composition, delegation, 라우팅 등을 직접 구현하는 형태로 제공
      * aggregation, routing 등을 직접 구현하는 형태로 제공

----

### ResponseResult 가이드 문서 추가 제공할 사항

* 통신 실패 시 Default 지원 방안
* 필수값인 경우
* 필수값이 아닌 경우


* 비즈니스 요구사항에 맞게 유연한 핸들링 지원 가능
~~~java
// 통신 실패 시 Default 지원 방안 예시

var member = memberClient
    .createXXX(...)
    .onFailure { errorResponse: ErrorResponse ->
        // 통신 실패시 callback,
    }
    .onSuccess { response: xxxResponse ->
       // 통신 성공시 callback
    }
    .getOrDefault(
        // 2xx 아닌 경우 기본 값 응답
        var default = xxxResponse(
            ...
        )
        return default;
    )
~~~


~~~java
    private static final String COMMON_ERROR_FORMAT = "{}.<{}:{}>,<uri:{}?{}>,trace:{}";

    log.error(COMMON_ERROR_FORMAT, message, ExceptionCode.SYS_ERROR_CODE_9302.getCode(),
        ExceptionCode.SYS_ERROR_CODE_9302.getDesc(),
        req.getRequestURI(), StringUtils.defaultString(req.getQueryString()),
        ExceptionUtils.getStackTrace(e));


~~~



## 추가 구조 개선
* RestApiClient 를 걷어내고 HTTP Service Interface 기반으로 변경 할 것인지?
  * 그럴 경우 장단점은?
  * 현재 사용중인 기능은?
  * @ImportHttpService 를 사용하여 restclient 를 구성하는 방안
  * 예외 처리 방법
  * 기본 RestClient 대신에 HttpClient5 적용 방안
    * 커넥션풀 관리 방법
    * http/2 적용 방안

* 외부(주로 프론트 레이어) 요청을 어떻게 인입 받고 응답처리 해야 하는지?
* 외부(주로 프론트 레이어) 요청을 처리하는 기능
  * bff 라우팅(프록시) 기능
    1. 외부 요청을 받아 router 를 통해 목적지로 전달
    2. 목적지로 전달된 요청을 처리하고 응답을 반환
    3. 응답을 반환

  * bff aggregation 기능 가이드
    1. 외부 요청을 받아 여러개의 요청을 목적지로 요청
    2. 각 목적지로 전달된 요청을 처리하고 응답을 반환
    3. 응답을 반환

* 스트리밍 또는 SSE 와 멀티파트 요청 처리 방안 - 후순위(3)
  * 실제 요청 사항이 있을지 검토 필요

* 성능 최적화
  * restclient timeout 설정
  * connection pool 설정
  * http2 적용
  * circuit breaker 적용
  * retry 설정
  * rate limiting 설정

* HTTP interface clients 기반의 통합테스트 작성
  * 예제 코드 생성 및 공유

* 부분 실패 허용 (Partial Failure) 여부 검토
  * aggregation 시 일부 api 호출 실패 시 나머지 api 호출을 계속 진행하고, 응답을 반환하는 기능


* cjos-commons 프레임워크 적용 방안

---
---


# prompt
~~~

기존에 구성하였던 RestApiClient 패키지를 제거 했습니다.
BFF_HTTP_SERVICE_INTERFACE_GUIDE.md 문서를 기반으로 현재 프로젝트에서 프레임워크 화 해주세요.
해당 데모를 프레임워크 화 하여 별도의 템플릿 데모를 구성하고 각 부서에 제공하려고 합니다.

* Spring MVC + HTTP Service Interface 기반
* 주요 기능들을 인터페이스 기반으로 구성하여 확장여부를 고려하면서 구성
* 테스트 코드 작성
~~~

~~~txt
 삭제된문서는 복구:
* BFF_IMPLEMENTATION.md                                                    
* BFF_USAGE_GUIDE.md                                                    
* BFF_API_GATEWAY_USAGE_GUIDE.md   
~~~



---
## 추가 검토 기능
* 모든 응답스펙은 통일한다.


  * interceptor 추가 기능
    * 인증 이나 정책 적용을 위한 기능
    * interface 기반으로 구성
  * converter - optional
    * 변환기 - 요청/응답 포맷 변환
    * interface 기반으로 구성
  * filter - optional
    * 필터 - 요청/응답을 필터링
    * interface 기반으로 구성하여 직접 구현 가능
  * yaml 기반의 설정 관리를 제공하는 기능 - 검토 중
    * spring cloud gateway 의 설정을 참조하여 구성



# 테스트
~~~ groovy
plugins {
    id 'org.springframework.boot' version '4.0.x'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'java'

    // Spring AOT (Spring Boot 플러그인에서 제공)
    id 'org.springframework.boot.aot' // 4.0 기준 명칭/사용은 공식 문서 참고

    // GraalVM Native Build Tools
    id 'org.graalvm.buildtools.native' version '0.11.1'
}
~~~

# 검토중인 기능
  * converter - optional
    * 변환기 - 요청/응답 포맷 변환
  * filter - optional
    * 필터 - 요청/응답을 필터링
  * yaml 기반의 설정 관리를 제공하는 기능을 무엇이라 명명할 것인지?


예외 처리

API 통신간 에러 유형
* 클라이언트 오류
  * client -> bff : 클라이언트 오류
    * http status code : 4xx
* 서버 오류
  * bff (self) : bff 서버 내부 오류
    * http status code : 5xx
  * bff -> api : bff 서버에서 내부 public api 호출 시 발생하는 오류
    * http status code : 5xx


* 예외처리 응답 구조
  * Http status code
  * Error code
  * Error message

  * Error custom message ? -> optional


---
* yaml 설정 기반의 관리형으로 구성할 것인지? -> 파트 내 논의 필요
  * 장단점?
  * 강점으로 추천할 만할 사항
  * yaml 설정을 옵셔널로 제공할 것인지?


## 기존 bff-api yaml 설정
### yaml 기반의 관리형

#### AS-IS 기본형
~~~yaml

bff:
  clients:
    api-clients:
      user:
        base-url: https://dev-user.cjonstyle.com
        connect-timeout: 2s
        http2:
            enabled: true
        max-in-memory-size: 256KB

  routes:  # 라우트 설정 - 어디에서 요청을 가져와서 어디로 보낼것 인가
    - id: user-svc-dashboard
      predicates: # 유효성 검증
        - name: pathPredicate
          args: /v3/**          #ant pattern
        - name: methodPredicate
          args: GET
      handlerMethod: getDashboard
      description: 사용자 서비스의 대시보드 출력 정보

~~~

#### AS-IS 단축형
~~~yaml

bff:
  clients:
    api-clients:
      user:
        base-url: https://dev-user.cjonstyle.com
        connect-timeout: 2s
        http2:
            enabled: true
        max-in-memory-size: 256KB

  routes:  # 라우트 설정 - 어디에서 요청을 가져와서 어디로 보낼것 인가
    - id: user-svc-dashboard
      predicates: # 유효성 검증 
        - Path=/api/v1/**
        - Method=GET,POST,PUT
        - Header=Authorization,Bearer.*
      handlerMethod: getDashboard
      description: 사용자 서비스의 대시보드 출력 정보 #설명 용도 


~~~




----

* 추가 고려할 사항
  * 변환기 -> ? 포맷 변환 부터 
  * 요청 최적화? -> 캐싱 등의 처리? etag 사용 방안?
  * CompletableFuture 사용 고려
  * 성능 최적화
    * virtual thread 도입
    * Rate limit
    * Retry
    * resilience
      * fallback
    * cache
    * circuit breaker
    * load balancer
    * timeout
    * metrics
    * tracing
    * logging
    * monitoring
    * alerting

  * cjos-commons 프레임워크 적용 방안

  * 요청 응답 모델 생성



# BFF에서 꼭 고려해야 할 추가 최적화
## 어그리게이션 처리를 할 때 성능을 더 끌어올리는 두 가지 팁

### API 라우팅 (Routing) 최적화
* 병렬 처리를 위한 CompletableFuture 사용

### API 어그리게이션 (Aggregation) 최적화
* 프론트엔드에서 "예시)마이페이지"를 요청했을 때, BFF가 내부의 여러 서비스를 호출해 데이터를 합쳐서 보내주는 과정
* 병렬 처리를 위한 CompletableFuture 사용


### ① 부분 실패 허용 (Partial Failure)
* 만약 '포인트 서비스'가 장애가 나서 응답이 안 온다면 마이페이지 전체를 에러로 띄워야 할까요?
* 해결: exceptionally()를 사용하여 포인트 정보만 0점 혹은 확인 불가로 채워서 보내줄 수 있습니다.
* 효과: 서비스의 안정성(Resilience)이 비약적으로 높아집니다.

### ② 데이터 필터링 (Over-fetching 방지)
* 내부 API들은 아주 방대한 데이터를 줍니다. BFF는 프론트엔드에 딱 필요한 데이터만 골라서 보내야 합니다.
* 방법: 내부 API에서 받은 큰 객체를 필요한 필드만 있는 가벼운 DTO로 변환합니다.
* 효과: 앞서 배운 네트워크 최적화와 연결되어, 모바일 기기의 데이터 사용량을 줄이고 화면 렌더링 속도를 높입니다.

### 요약: BFF 설계 원칙
* 동시성: 여러 내부 API 호출은 무조건 **병렬(CompletableFuture)**로 처리한다.
* 가벼운 일꾼: 서버 자원 절약을 위해 가상 스레드를 활성화한다.
* 내결함성: 하나가 실패해도 전체가 죽지 않도록 예외 처리를 철저히 한다.
* 최소 전송: 프론트엔드에는 최소한의 필요한 데이터만 정제해서 보낸다.




----
----

# 별도 프로젝트 고려할 사항인지?

* 캐시 기능 고도화? -> 다음 사이드 프로젝트로 변경
  * 1차, 2차 캐시 동기화?
    * DB 업데이트 시 2차 캐시 -> 1차 캐시로 전파?





~~~java
package com.example.demo.config;

import com.example.demo.client.MyClient;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;
import org.apache.hc.client5.http.socket.ConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;
import org.apache.hc.core5.http.io.SocketConfig;
import org.apache.hc.core5.util.Timeout;
import org.springframework.boot.ssl.SslBundle;
import org.springframework.boot.ssl.SslBundles;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.service.registry.HttpServiceGroupConfigurer;
import org.springframework.web.service.registry.ImportHttpServices;

import javax.net.ssl.SSLContext;
import java.util.concurrent.TimeUnit;

@Configuration
@ImportHttpServices(group = "my-service", types = MyClient.class)
public class ServiceConfig {

    @Bean
    public HttpServiceGroupConfigurer myServiceConfigurer(SslBundles sslBundles) {
        return groups -> groups.filterByName("my-service")
                .configure(builder -> {
                    
                    // 1. SSL Context 가져오기 (yml에 설정한 번들 이름)
                    SslBundle sslBundle = sslBundles.getBundle("my-service-ssl");
                    SSLContext sslContext = sslBundle.createSslContext();

                    // 2. Apache HttpClient의 Connection Manager 설정 (커넥션 풀)
                    PoolingHttpClientConnectionManager connectionManager = 
                            createConnectionManager(sslContext);

                    // 3. Apache HttpClient 생성
                    CloseableHttpClient httpClient = HttpClients.custom()
                            .setConnectionManager(connectionManager)
                            .evictIdleConnections(TimeValue.ofSeconds(30)) // 유휴 커넥션 정리
                            .build();

                    // 4. Spring의 RequestFactory로 래핑하여 RestClient 빌더에 설정
                    builder.requestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
                    
                    // 5. Base URL 등 기타 설정
                    builder.baseUrl("https://secure-api.example.com");
                });
    }

    // 커넥션 풀 상세 설정 헬퍼 메서드
    private PoolingHttpClientConnectionManager createConnectionManager(SSLContext sslContext) {
        // SSL 소켓 팩토리 연결
        SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext);

        PoolingHttpClientConnectionManager connManager = 
                org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder.create()
                .setSSLSocketFactory(sslSocketFactory)
                .build();

        // 풀 사이즈 설정
        connManager.setMaxTotal(100); // 전체 최대 커넥션 수
        connManager.setDefaultMaxPerRoute(20); // 호스트(Route) 당 최대 커넥션 수

        // 소켓 설정 (선택 사항)
        connManager.setDefaultSocketConfig(SocketConfig.custom()
                .setSoTimeout(Timeout.of(10, TimeUnit.SECONDS))
                .build());

        return connManager;
    }
}
~~~

# 핵심 포인트
* HttpServiceGroupConfigurer:
  * 이전 답변과 마찬가지로 이 인터페이스가 설정의 진입점입니다.

* SSL 적용 (SslBundles):
  * sslBundles.getBundle("이름")을 통해 SSL 컨텍스트를 가져와서 하위 HTTP 클라이언트(Apache HttpClient 등)에 주입합니다.

  * 단순히 SSL만 적용하고 커넥션 풀이 필요 없다면, 빌더 자체에 builder.apply(ssl.fromBundle("name")) 같은 편의 메서드가 제공될 수도 있습니다(버전 상황에 따라 다름). 하지만 커넥션 풀을 쓰려면 Native Client를 직접 만들어야 하므로 위와 같이 SSLContext를 추출해서 쓰는 것이 정확합니다.

* 커넥션 풀 (PoolingHttpClientConnectionManager):
  * RestClient 자체에는 풀링 기능이 없습니다.

  * 따라서 Apache HttpClient 같은 실제 통신 라이브러리의 인스턴스를 생성하고, 이를 HttpComponentsClientHttpRequestFactory로 감싸서 builder.requestFactory()에 넣어주어야 합니다.
  * 이 방식을 사용하면 @ImportHttpServices의 편리함(인터페이스 자동 구현)을 유지하면서도, 엔터프라이즈 환경에서 필수적인 Connection Pool 제어와 보안(SSL) 설정을 완벽하게 처리




  ~~~