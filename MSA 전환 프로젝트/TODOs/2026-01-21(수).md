2026-01-21(수)

어플리케이션 역할에 따른 추가 라이브러리 작업  2026. 2. 6. 진행중

* bff-api
* public-api
* publisher
* consumer




# 명칭에 대한 논의
* 네이밍

bff 구조 명칭
Bff 액세스 로그 
* 버전 로그, 로그포맷
* 

* api-gateway 패턴

public-api


이벤트 생성
이벤트 소비

파이프라인?

-----

bff 추가 작업할 사항
* 프레임워크에 적용 - 진행중
* 가이드 문서 정리 - 진행중

* 추가 기능 고려할 사항
  * RestClient 또는 webClient 추가를 위한 interceptor 구현 - 가능한지 먼저 검토
    * 인증 이나 정책 적용을 위한 interceptor 적용 가능성 검토
    * interface 기반으로 구성
  * RestClient 또는 webClient 교체 가능 여부 검토
    * 커넥션 풀, http/2, 타임아웃 세부 설정 등의 목적
  * API 어그리게이션 현재 구현된 내용 점검 및 추가 인터페이스 구현여부 검토
    * API 어그리게이션 패턴 정의 - 문서 정리(도식 및 패턴에 대한 상세 설명 추가)
        * 순차 어그리게이션 (기본) :  단순하고 디버깅이 쉬우나, 총 응답 시간 = 각 호출 시간의 합
        * 병렬 어그리게이션 : CompletableFuture를 사용하여 독립적인 API 호출을 병렬로 실행
        * 의존적 호출 (단계별 병렬화) : 일부 호출이 이전 결과에 의존하는 경우(예시 : 첫 번째 호출 결과를 사용하여 두 번째 호출을 실행하는 방식)
    * 어그리게이션 유틸리티 
      * ParallelFetcher 검토
        * 성능 테스트 필요
        * 추가로 구현할 메소드 패턴 검토

  * virtual thread 설정 관리 방안
    * 모듈 내 config Bean 설정을 제거


* 테스트 
  * 단위 테스트
  * 통합 테스트
  * 성능 테스트

* 문서
  * 가이드 문서 정리
    * BFF_FRAMEWORK_GUIDE.md 문서 현행화 -> ResponseResult 반영
    * BFF_QUICK_START.md 문서 현행화 -> ResponseResult 반영
  * 사용자 문서 정리
    * 추가로 버저닝 방법도 가이드 문서에 포함
        * BFF_HTTP_SERVICE_INTERFACE_GUIDE.md
* 데모 준비
  * 데모 샘플 구성







----

## `org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일의 목적

이 파일은 **Spring Boot 3.x의 자동 구성(Auto Configuration) 등록 메커니즘**입니다.

### 목적
- `@AutoConfiguration` 클래스를 Spring Boot에 등록하여 애플리케이션 시작 시 자동으로 로드되도록 합니다.
- `BffAutoConfiguration` 클래스가 이 공통 라이브러리를 의존성으로 추가한 프로젝트에서 자동으로 활성화됩니다.

### 필요성
| 이유 | 설명 |
|------|------|
| **자동 빈 등록** | 라이브러리 사용자가 별도 설정 없이 공통 빈들을 사용 가능 |
| **모듈화** | 공통 기능을 별도 모듈로 분리하여 재사용성 향상 |
| **Spring Boot 3.x 표준** | 기존 `spring.factories` 방식을 대체하는 새로운 표준 방식 |

### 동작 방식
다른 Spring Boot 프로젝트에서 이 라이브러리를 의존성으로 추가하면, `BffAutoConfiguration`이 자동으로 스캔되어 해당 클래스에 정의된 빈들이 등록됩니다.


----


# API 어그리게이션 mermaid 도식 정리

~~~mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#3a3a3a',        /* 노드 배경색 (어두운 회색) */
    'primaryTextColor': '#e0e0e0',    /* 노드 글자색 (밝은 회색) */
    'primaryBorderColor': '#666666',  /* 노드 테두리색 */
    'lineColor': '#aaaaaa',           /* 화살표 선 색상 */
    'secondaryColor': '#2a2a2a',      /* 서브그래프(그룹) 배경색 */
    'tertiaryColor': '#222222',       /* 전체 배경색 (렌더러 지원 시) */
    'fontFamily': 'Helvetica, Arial, sans-serif'
  }
}}%%

graph TB
    %% --- 스타일 정의 ---
    %% 노드 모양과 추가적인 스타일을 강제하고 싶을 때 사용합니다.
    classDef darkNode fill:#3a3a3a,stroke:#666,stroke-width:1px,color:#e0e0e0;

    %% --- 1. 순차 호출 패턴 ---
    subgraph Sequential [순차 호출]
        direction LR
        S_A[A] --> S_B[B] --> S_C[C]
    end

    %% --- 2. 병렬 호출 패턴 ---
    subgraph Parallel [병렬 호출]
        direction LR
        P_A[A] --> P_Res[Result]
        P_B[B] --> P_Res
        P_C[C] --> P_Res
    end

    %% --- 3. 의존 호출 패턴 ---
    subgraph Dependent [의존 호출]
        direction TB
        D_A[A]
        %% B와 C를 같은 레벨에 두고 동시에 실행됨을 표현
        D_BC_Group[B, C 동시 실행]
        
        %% A가 끝나면 B,C 그룹으로 진행
        D_A --> D_BC_Group
        
        %% B,C 그룹이 끝나면 D로 진행
        D_BC_Group --> D_D["D<br/>(B,C 결과 사용)"]

        %% 위 방식이 마음에 안 들 경우, 아래처럼 노드를 개별로 분리할 수도 있습니다.
        %% D_A2[A] --> D_B2[B] & D_C2[C]
        %% D_B2 & D_C2 --> D_D2["D<br/>(B,C 결과 사용)"]
    end

    %% --- 스타일 적용 (init 테마가 제대로 적용 안 될 경우를 대비한 명시적 클래스) ---
    class S_A,S_B,S_C,P_A,P_B,P_C,P_Res,D_A,D_BC_Group,D_D darkNode;
~~~











----



                     
                                                                                                                                                                                                                                
  추천 근거                                                                                                                                                                                                                     
                                                                                                                                                                                                                                
  1. 실용적 관점                                                                                                                                                                                                                
  ┌───────────────────┬─────────────────────┬─────────────────────┐                                                                                                                                                             
  │       기준        │      Option A       │      Option B       │                                                                                                                                                             
  ├───────────────────┼─────────────────────┼─────────────────────┤                                                                                                                                                             
  │ 마이그레이션 비용 │ 낮음                │ 높음                │                                                                                                                                                             
  ├───────────────────┼─────────────────────┼─────────────────────┤                                                                                                                                                             
  │ 기존 코드 호환성  │ errorMessage() 유지 │ 접근 방식 변경 필요 │                                                                                                                                                             
  ├───────────────────┼─────────────────────┼─────────────────────┤                                                                                                                                                             
  │ 구현 복잡도       │ 단순                │ 중첩 레코드 관리    │                                                                                                                                                             
  └───────────────────┴─────────────────────┴─────────────────────┘                                                                                                                                                             
  2. 현재 요구사항 충족                                                                                                                                                                                                         
                                                                                                                                                                                                                                
  Option A의 statusCode와 errorCode 두 필드만으로도 문서에서 제기된 모든 문제가 해결됩니다:                                                                                                                                     
  - toResponseResult() 정확한 상태 코드 전달                                                                                                                                                                                    
  - 타임아웃/503/4xx 에러 구분                                                                                                                                                                                                  
  - 재시도 가능 여부 판단                                                                                                                                                                                                       
                                                                                                                                                                                                                                
  3. YAGNI 원칙                                                                                                                                                                                                                 
                                                                                                                                                                                                                                
  Option B는 "향후 path, details, timestamp 같은 필드가 추가될 수 있다"는 가정에 기반합니다. 하지만:                                                                                                                            
  - AggregationResult는 내부 집계 결과를 담는 용도                                                                                                                                                                              
  - 상세한 에러 정보는 이미 ResponseResult → ErrorResponse에서 처리                                                                                                                                                             
  - 실제로 그런 확장이 필요할 때 리팩토링해도 늦지 않음                                                                                                                                                                         
                                                                                                                                                                                                                                
  4. 일관성 측면에서의 반론                                                                                                                                                                                                     
                                                                                                                                                                                                                                
  Option B가 ErrorResponse와 구조적으로 유사하다는 장점이 있지만, AggregationResult와 ResponseResult는 역할이 다릅니다:                                                                                                         
  - ResponseResult: 최종 HTTP 응답 표현 (클라이언트에게 전달)                                                                                                                                                                   
  - AggregationResult: 병렬 호출의 중간 집계 결과 (내부 처리용)                                                                                                                                                                 
                                                                                                                                                                                                                                
  내부 처리용 객체는 단순할수록 좋습니다.                                                                                                                                                                                       
                                                                                                                                                                                                                                
  ---                                                                                                                                                                                                                           
  단, Option B를 선택해야 할 상황: 향후 Circuit Breaker 상태, 재시도 횟수, 실패 시각 등 에러 메타데이터가 확실히 필요하다면 Option B가 더 적합합니다.  





   위치: src/main/resources/docs/                                                                     
  ┌──────────────────────────────────────────┬───────────────────────────────────┐                   
  │                  파일명                  │               설명                │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ AGGREGATION_RESULT_IMPROVEMENT_REVIEW.md │ 집계 결과 개선 검토               │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ BFF_COMPARISON_AND_MIGRATION_GUIDE.md    │ BFF 비교 및 마이그레이션 가이드   │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ BFF_FRAMEWORK_GUIDE.md                   │ BFF 프레임워크 가이드             │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ BFF_HTTP_SERVICE_INTERFACE_GUIDE.md      │ HTTP Service 인터페이스 가이드    │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ BFF_QUICK_START.md                       │ 빠른 시작 가이드                  │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ BFF_TEMPLATE_API_REVIEW.md               │ 템플릿 API 검토                   │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ HTTP_CLIENT_INTERCEPTOR_GUIDE.md         │ HTTP 클라이언트 인터셉터 가이드   │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ HTTP_SERVICE_INTERFACE_GUIDE.md          │ HTTP Service 인터페이스 가이드    │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ HTTP_SERVICE_USAGE_GUIDE.md              │ HTTP Service 사용 가이드          │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ INTERCEPTOR_INTEGRATION_GUIDE.md         │ 인터셉터 통합 가이드              │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ RESPONSE_RESULT_GUIDE.md                 │ 응답 결과 가이드                  │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ RESTAPICLIENT_VS_HTTPSERVICE_ANALYSIS.md │ RestApiClient vs HttpService 분석 │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ RESTCLIENT_WEBCLIENT_REVIEW.md           │ RestClient/WebClient 검토         │                   
  ├──────────────────────────────────────────┼───────────────────────────────────┤                   
  │ SECURITY_PERFORMANCE_REVIEW.md           │ 보안/성능 검토                    │                   
  └──────────────────────────────────────────┴───────────────────────